use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::Mutex;

use ethers::{
    abi::AbiDecode,
    providers::{Middleware, Provider, StreamExt, TransactionStream, Ws},
    types::Transaction,
};

use crate::address_book::UniV2RouterCalls;
use crate::strategy::StrategyManager;
use crate::alert::alert;

pub async fn loop_mempool(ws_provider: Arc<Provider<Ws>>) {
    // Subscribe on newPendingTransactions.
    let tx_hash_stream = ws_provider.subscribe_pending_txs().await.unwrap();
    let mut tx_stream = TransactionStream::new(&ws_provider, tx_hash_stream, 256);

    println!("---------- MONITORING MEMPOOL ----------");
    while let Some(maybe_tx) = tx_stream.next().await {
        if let Ok(tx) = maybe_tx {
            if let Ok(decoded) = UniV2RouterCalls::decode(&tx.input) {
                println!("Transaction: {:#?}\nRouter Call: {:#?}\n", tx, decoded);
            }
        }
    }
}

pub async fn loop_mempool_with_strategies(
    ws_provider: Arc<Provider<Ws>>,
    strategy_manager: Arc<StrategyManager>,
) {
    // Track processed transactions to avoid duplicates
    let processed_txs = Arc::new(Mutex::new(HashMap::new()));
    
    // Subscribe to pending transactions
    let tx_hash_stream = ws_provider.subscribe_pending_txs().await.unwrap();
    let mut tx_stream = TransactionStream::new(&ws_provider, tx_hash_stream, 256);

    println!("üîç MEV Bot Active - Monitoring Mempool");
    println!("---------- SCANNING FOR OPPORTUNITIES ----------");
    
    while let Some(maybe_tx) = tx_stream.next().await {
        if let Ok(tx) = maybe_tx {
            // Skip if we've already processed this transaction
            let mut processed = processed_txs.lock().await;
            if processed.contains_key(&tx.hash) {
                continue;
            }
            processed.insert(tx.hash, true);
            
            // Only analyze transactions to routers
            if is_router_transaction(&tx) {
                // Spawn a task to analyze this transaction
                let strategy_manager_clone = strategy_manager.clone();
                let ws_provider_clone = ws_provider.clone();
                
                tokio::spawn(async move {
                    analyze_and_execute(tx, strategy_manager_clone, ws_provider_clone).await;
                });
            }
        }
    }
}

async fn analyze_and_execute(
    tx: Transaction,
    strategy_manager: Arc<StrategyManager>,
    ws_provider: Arc<Provider<Ws>>,
) {
    // Decode router call for logging
    if let Ok(decoded) = UniV2RouterCalls::decode(&tx.input) {
        println!("\nüéØ Analyzing Transaction: {}", tx.hash);
        println!("   Router Call: {:?}", get_call_type(&decoded));
        println!("   Gas Price: {} gwei", tx.gas_price.unwrap_or_default() / 1_000_000_000u64);
    }
    
    // Analyze transaction for MEV opportunities
    let opportunities = strategy_manager.analyze_transaction(&tx).await;
    
    if opportunities.is_empty() {
        return;
    }
    
    println!("üí∞ Found {} MEV opportunities!", opportunities.len());
    
    // Sort opportunities by priority and profit
    let mut sorted_opportunities = opportunities;
    sorted_opportunities.sort_by(|a, b| {
        b.priority.cmp(&a.priority)
            .then_with(|| b.estimated_profit.cmp(&a.estimated_profit))
    });
    
    // Execute the best opportunity
    for opportunity in sorted_opportunities.iter() {
        println!("\nüöÄ Executing MEV Strategy:");
        println!("   Type: {:?}", opportunity.strategy_type);
        println!("   Estimated Profit: {} ETH", 
                 ethers::utils::format_ether(opportunity.estimated_profit));
        println!("   Gas Cost: {} ETH", 
                 ethers::utils::format_ether(opportunity.gas_cost));
        
        match strategy_manager.execute_opportunity(opportunity).await {
            Ok(tx_hash) => {
                println!("‚úÖ MEV Bundle Submitted: {}", tx_hash);
                
                // Send alert about successful opportunity
                let current_block = ws_provider.get_block_number().await.unwrap_or_default();
                let msg = format!(
                    "MEV Opportunity Executed!\nType: {:?}\nProfit: {} ETH\nTx: {}",
                    opportunity.strategy_type,
                    ethers::utils::format_ether(opportunity.estimated_profit),
                    tx_hash
                );
                alert(&msg, &current_block.as_u64()).await;
                
                break; // Only execute one opportunity per transaction
            },
            Err(e) => {
                println!("‚ùå Failed to execute MEV strategy: {}", e);
            }
        }
    }
}

fn is_router_transaction(tx: &Transaction) -> bool {
    // Check if transaction is to a known router
    let routers = vec![
        "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2
        "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F", // Sushiswap
        "0xE592427A0AEce92De3Edee1F18E0157C05861564", // Uniswap V3
    ];
    
    if let Some(to) = tx.to {
        routers.iter().any(|&router| {
            to == router.parse::<ethers::types::Address>().unwrap()
        })
    } else {
        false
    }
}

fn get_call_type(call: &UniV2RouterCalls) -> &'static str {
    match call {
        UniV2RouterCalls::SwapExactETHForTokens(_) => "SwapExactETHForTokens",
        UniV2RouterCalls::SwapExactTokensForETH(_) => "SwapExactTokensForETH",
        UniV2RouterCalls::SwapExactTokensForTokens(_) => "SwapExactTokensForTokens",
        UniV2RouterCalls::SwapETHForExactTokens(_) => "SwapETHForExactTokens",
        UniV2RouterCalls::SwapTokensForExactETH(_) => "SwapTokensForExactETH",
        UniV2RouterCalls::SwapTokensForExactTokens(_) => "SwapTokensForExactTokens",
        UniV2RouterCalls::SwapExactETHForTokensSupportingFeeOnTransferTokens(_) => "SwapExactETHForTokensFeeOnTransfer",
        UniV2RouterCalls::SwapExactTokensForETHSupportingFeeOnTransferTokens(_) => "SwapExactTokensForETHFeeOnTransfer",
        UniV2RouterCalls::SwapExactTokensForTokensSupportingFeeOnTransferTokens(_) => "SwapExactTokensForTokensFeeOnTransfer",
        _ => "Other",
    }
}
